Created by PLY version 3.6 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> commande
Rule 1     commande -> bouger commande
Rule 2     commande -> bouger
Rule 3     commande -> attendre commande
Rule 4     commande -> attendre
Rule 5     commande -> toucher commande
Rule 6     commande -> toucher
Rule 7     bouger -> move lbracket digit separator digit rbracket
Rule 8     toucher -> touch lbracket rbracket
Rule 9     toucher -> touch
Rule 10    attendre -> wait lbracket digit rbracket

Terminals, with rules where they appear

digit                : 7 7 10
error                : 
lbracket             : 7 8 10
move                 : 7
rbracket             : 7 8 10
separator            : 7
touch                : 8 9
wait                 : 10

Nonterminals, with rules where they appear

attendre             : 3 4
bouger               : 1 2
commande             : 1 3 5 0
toucher              : 5 6

Parsing method: LALR

state 0

    (0) S' -> . commande
    (1) commande -> . bouger commande
    (2) commande -> . bouger
    (3) commande -> . attendre commande
    (4) commande -> . attendre
    (5) commande -> . toucher commande
    (6) commande -> . toucher
    (7) bouger -> . move lbracket digit separator digit rbracket
    (10) attendre -> . wait lbracket digit rbracket
    (8) toucher -> . touch lbracket rbracket
    (9) toucher -> . touch

    move            shift and go to state 2
    wait            shift and go to state 7
    touch           shift and go to state 5

    toucher                        shift and go to state 1
    bouger                         shift and go to state 3
    attendre                       shift and go to state 6
    commande                       shift and go to state 4

state 1

    (5) commande -> toucher . commande
    (6) commande -> toucher .
    (1) commande -> . bouger commande
    (2) commande -> . bouger
    (3) commande -> . attendre commande
    (4) commande -> . attendre
    (5) commande -> . toucher commande
    (6) commande -> . toucher
    (7) bouger -> . move lbracket digit separator digit rbracket
    (10) attendre -> . wait lbracket digit rbracket
    (8) toucher -> . touch lbracket rbracket
    (9) toucher -> . touch

    $end            reduce using rule 6 (commande -> toucher .)
    move            shift and go to state 2
    wait            shift and go to state 7
    touch           shift and go to state 5

    attendre                       shift and go to state 6
    bouger                         shift and go to state 3
    toucher                        shift and go to state 1
    commande                       shift and go to state 8

state 2

    (7) bouger -> move . lbracket digit separator digit rbracket

    lbracket        shift and go to state 9


state 3

    (1) commande -> bouger . commande
    (2) commande -> bouger .
    (1) commande -> . bouger commande
    (2) commande -> . bouger
    (3) commande -> . attendre commande
    (4) commande -> . attendre
    (5) commande -> . toucher commande
    (6) commande -> . toucher
    (7) bouger -> . move lbracket digit separator digit rbracket
    (10) attendre -> . wait lbracket digit rbracket
    (8) toucher -> . touch lbracket rbracket
    (9) toucher -> . touch

    $end            reduce using rule 2 (commande -> bouger .)
    move            shift and go to state 2
    wait            shift and go to state 7
    touch           shift and go to state 5

    toucher                        shift and go to state 1
    bouger                         shift and go to state 3
    attendre                       shift and go to state 6
    commande                       shift and go to state 10

state 4

    (0) S' -> commande .



state 5

    (8) toucher -> touch . lbracket rbracket
    (9) toucher -> touch .

    lbracket        shift and go to state 11
    move            reduce using rule 9 (toucher -> touch .)
    wait            reduce using rule 9 (toucher -> touch .)
    touch           reduce using rule 9 (toucher -> touch .)
    $end            reduce using rule 9 (toucher -> touch .)


state 6

    (3) commande -> attendre . commande
    (4) commande -> attendre .
    (1) commande -> . bouger commande
    (2) commande -> . bouger
    (3) commande -> . attendre commande
    (4) commande -> . attendre
    (5) commande -> . toucher commande
    (6) commande -> . toucher
    (7) bouger -> . move lbracket digit separator digit rbracket
    (10) attendre -> . wait lbracket digit rbracket
    (8) toucher -> . touch lbracket rbracket
    (9) toucher -> . touch

    $end            reduce using rule 4 (commande -> attendre .)
    move            shift and go to state 2
    wait            shift and go to state 7
    touch           shift and go to state 5

    toucher                        shift and go to state 1
    bouger                         shift and go to state 3
    attendre                       shift and go to state 6
    commande                       shift and go to state 12

state 7

    (10) attendre -> wait . lbracket digit rbracket

    lbracket        shift and go to state 13


state 8

    (5) commande -> toucher commande .

    $end            reduce using rule 5 (commande -> toucher commande .)


state 9

    (7) bouger -> move lbracket . digit separator digit rbracket

    digit           shift and go to state 14


state 10

    (1) commande -> bouger commande .

    $end            reduce using rule 1 (commande -> bouger commande .)


state 11

    (8) toucher -> touch lbracket . rbracket

    rbracket        shift and go to state 15


state 12

    (3) commande -> attendre commande .

    $end            reduce using rule 3 (commande -> attendre commande .)


state 13

    (10) attendre -> wait lbracket . digit rbracket

    digit           shift and go to state 16


state 14

    (7) bouger -> move lbracket digit . separator digit rbracket

    separator       shift and go to state 17


state 15

    (8) toucher -> touch lbracket rbracket .

    move            reduce using rule 8 (toucher -> touch lbracket rbracket .)
    wait            reduce using rule 8 (toucher -> touch lbracket rbracket .)
    touch           reduce using rule 8 (toucher -> touch lbracket rbracket .)
    $end            reduce using rule 8 (toucher -> touch lbracket rbracket .)


state 16

    (10) attendre -> wait lbracket digit . rbracket

    rbracket        shift and go to state 18


state 17

    (7) bouger -> move lbracket digit separator . digit rbracket

    digit           shift and go to state 19


state 18

    (10) attendre -> wait lbracket digit rbracket .

    move            reduce using rule 10 (attendre -> wait lbracket digit rbracket .)
    wait            reduce using rule 10 (attendre -> wait lbracket digit rbracket .)
    touch           reduce using rule 10 (attendre -> wait lbracket digit rbracket .)
    $end            reduce using rule 10 (attendre -> wait lbracket digit rbracket .)


state 19

    (7) bouger -> move lbracket digit separator digit . rbracket

    rbracket        shift and go to state 20


state 20

    (7) bouger -> move lbracket digit separator digit rbracket .

    move            reduce using rule 7 (bouger -> move lbracket digit separator digit rbracket .)
    wait            reduce using rule 7 (bouger -> move lbracket digit separator digit rbracket .)
    touch           reduce using rule 7 (bouger -> move lbracket digit separator digit rbracket .)
    $end            reduce using rule 7 (bouger -> move lbracket digit separator digit rbracket .)

